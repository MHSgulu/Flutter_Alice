import 'dart:async';

import 'package:matcher/matcher.dart';
import 'package:meta/meta.dart';

/// An exception thrown when a test assertion fails.
class TestFailure {
  /// An exception thrown when a test assertion fails.
  TestFailure(this.message);

  /// Exception message
  final String message;

  @override
  String toString() => message;
}

/// The type used for functions that can be used to build up error reports
/// upon failures in [expect].
@Deprecated('Will be removed in 0.13.0.')
typedef ErrorFormatter = String Function(dynamic actual, Matcher matcher,
    String reason, Map matchState, bool verbose);

/// Assert that [actual] matches [matcher].
///
/// This is the main assertion function. [reason] is optional and is typically
/// not supplied, as a reason is generated from [matcher]; if [reason]
/// is included it is appended to the reason generated by the matcher.
///
/// [matcher] can be a value in which case it will be wrapped in an
/// [equals] matcher.
///
/// If the assertion fails a [TestFailure] is thrown.
///
/// If [skip] is a String or `true`, the assertion is skipped. The arguments are
/// still evaluated, but [actual] is not verified to match [matcher]. If
/// [actual] is a [Future], the test won't complete until the future emits a
/// value.
///
/// If [skip] is a string, it should explain why the assertion is skipped; this
/// reason will be printed when running the test.
///
/// Certain matchers, like [completion] and [throwsA], either match or fail
/// asynchronously. When you use [expect] with these matchers, it ensures that
/// the test doesn't complete until the matcher has either matched or failed. If
/// you want to wait for the matcher to complete before continuing the test, you
/// can call [expectLater] instead and `await` the result.

///断言[actual]与[matcher]匹配。
///
///这是主要的断言函数。 [原因]是可选的，通常不提供，原因是[匹配器]产生的原因；
///如果包含[reason]，则将其附加到匹配器生成的原因之后。
///
/// [matcher]可以是一个值，在这种情况下，它将被包装在[equals]匹配器中。
///
///如果断言失败，则抛出[TestFailure]。
///
///如果[skip]是String或`true`，则断言被跳过。仍对参数进行求值，但是未验证[actual]与[matcher]匹配。
///如果[actual]是[Future]，则该测试要等到将来发射一个值时才能完成。
///
///如果[skip]是字符串，则应说明为什么断言该断言；运行测试时将打印此原因。
///
///某些匹配器（例如[completion]和[throwsA]）匹配或异步失败。
///当将[expect]与这些匹配器一起使用时，它可以确保在匹配器匹配或失败之前测试不会完成。
///如果要在继续测试之前等待匹配器完成，可以改为调用[expectLater]并“等待”结果。
void expect(
    actual,
    matcher, {
      String reason,
      skip,
    }) {
  _expect(actual, matcher, reason: reason, skip: skip);
}

/// Just like [expect], but returns a [Future] that completes when the matcher
/// has finished matching.
///
/// For the [completes] and [completion] matchers, as well as [throwsA] and
/// related matchers when they're matched against a [Future], the returned
/// future completes when the matched future completes. For the [prints]
/// matcher, it completes when the future returned by the callback completes.
/// Otherwise, it completes immediately.
///
/// If the matcher fails asynchronously, that failure is piped to the returned
/// future where it can be handled by user code.
Future expectLater(actual, matcher, {String reason, skip}) =>
    _expect(actual, matcher, reason: reason, skip: skip);

String _formatFailure(Matcher expected, actual, String which, {String reason}) {
  var buffer = StringBuffer();
  buffer.writeln(indent(prettyPrint(expected), first: 'Expected: '));
  buffer.writeln(indent(prettyPrint(actual), first: '  Actual: '));
  if (which.isNotEmpty) buffer.writeln(indent(which, first: '   Which: '));
  if (reason != null) buffer.writeln(reason);
  return buffer.toString();
}

/// The implementation of [expect] and [expectLater].
Future _expect(actual, matcher,
    {String reason,
      skip,
      bool verbose = false,
      // ignore: deprecated_member_use, deprecated_member_use_from_same_package
      ErrorFormatter formatter}) {
  formatter ??= (actual, matcher, reason, matchState, verbose) {
    var mismatchDescription = StringDescription();
    matcher.describeMismatch(actual, mismatchDescription, matchState, verbose);

    // ignore: deprecated_member_use
    return _formatFailure(matcher, actual, mismatchDescription.toString(),
        reason: reason);
  };

  if (skip != null && skip is! bool && skip is! String) {
    throw ArgumentError.value(skip, 'skip', 'must be a bool or a String');
  }

  matcher = wrapMatcher(matcher);

  var matchState = {};
  try {
    if ((matcher as Matcher).matches(actual, matchState)) {
      return Future.sync(() {});
    }
  } catch (e, trace) {
    reason ??= '$e at $trace';
  }
  fail(formatter(actual, matcher as Matcher, reason, matchState, verbose));
}

/// Convenience method for throwing a new [TestFailure] with the provided
/// [message].
@alwaysThrows
void fail([String message]) => throw TestFailure(message ?? 'should fail');

/// index text helper.
String indent(String text, {String first}) {
  if (first != null) {
    return '$first $text';
  }
  return '$text';
}

/// index text helper.
String prettyPrint(dynamic text, {String first}) {
  if (first != null) {
    return '$first $text';
  }
  return '$text';
}

/// The default error formatter.
@Deprecated('Will be removed in 0.13.0.')
String formatFailure(Matcher expected, actual, String which, {String reason}) {
  var buffer = StringBuffer();
  buffer.writeln(indent(prettyPrint(expected), first: 'Expected: '));
  buffer.writeln(indent(prettyPrint(actual), first: '  Actual: '));
  if (which.isNotEmpty) buffer.writeln(indent(which, first: '   Which: '));
  if (reason != null) buffer.writeln(reason);
  return buffer.toString();
}